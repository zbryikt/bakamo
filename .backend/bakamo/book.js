// Generated by LiveScript 1.6.0
(function(){
  var fs, lderror, nodeFetch, aux;
  fs = require('fs');
  lderror = require('lderror');
  nodeFetch = require('node-fetch');
  aux = require('@servebase/backend/aux');
  (function(it){
    return module.exports = it;
  })(function(backend){
    return function(it){
      return it.apply(backend);
    }(function(){
      var db, ref$, api, app, config, key, bookFromGoogle;
      db = this.db, ref$ = this.route, api = ref$.api, app = ref$.app, config = this.config;
      key = config.google.key;
      bookFromGoogle = function(arg$){
        var isbn;
        isbn = arg$.isbn;
        if (!/^\d+$/.exec(isbn)) {
          return {
            isbn: isbn
          };
        }
        return nodeFetch("https://www.googleapis.com/books/v1/volumes?q=isbn:" + isbn + "&key=" + key, {
          method: 'GET',
          type: 'json'
        }).then(function(v){
          if (!(v && v.ok)) {
            return {
              isbn: isbn
            };
          }
          return v.json().then(function(ret){
            var item, title, author, ref$, thumbnail;
            item = (ret.items || (ret.items = []))[0] || {};
            title = (item.volumeInfo || (item.volumeInfo = {})).title;
            author = ((ref$ = item.volumeInfo).authors || (ref$.authors = []))[0] || '';
            thumbnail = ((ref$ = item.volumeInfo).imageLinks || (ref$.imageLinks = {})).thumbnail;
            return {
              isbn: isbn,
              title: title,
              author: author,
              thumbnail: thumbnail,
              detail: {
                raw: item,
                source: 'google book api'
              }
            };
          });
        });
      };
      api.post('/book/', function(req, res){
        var list;
        list = (Array.isArray(req.body.list)
          ? req.body.list
          : [req.body.list]).filter(function(it){
          return it;
        });
        return db.query("select * from book where isbn = ANY($1)", [list]).then(function(r){
          var ret, isbns, ps;
          r == null && (r = {});
          ret = r.rows || (r.rows = []);
          isbns = ret.map(function(it){
            return it.isbn;
          });
          ps = list.filter(function(it){
            return !in$(it, isbns);
          }).map(function(isbn){
            return bookFromGoogle({
              isbn: isbn
            });
          });
          return Promise.all(ps).then(function(ret){
            ret = ret.filter(function(it){
              return it.title;
            });
            return db.query("insert into book (isbn,title,author,detail)\nselect * from jsonb_to_recordset($1::jsonb) as e (isbn text, title text, author text, detail jsonb)", [JSON.stringify(ret)]);
          });
        }).then(function(){
          return db.query("select * from book where isbn = ANY($1)", [list]);
        }).then(function(r){
          r == null && (r = {});
          return res.send(r.rows || (r.rows = []));
        });
      });
      api.post('/read/:key?', aux.signedin, function(req, res){
        var owner, list;
        if (req.params.key && req.user.key !== req.params.key) {
          return lderror.reject(403);
        }
        if (isNaN(owner = +req.user.key)) {
          return lderror.reject(400);
        }
        list = (Array.isArray(req.body.list)
          ? req.body.list
          : [req.body.list]).filter(function(it){
          return it && it.book;
        }).map(function(it){
          return it.owner = owner, it;
        });
        return db.query("insert into read (owner, book, enddate)\nselect * from jsonb_to_recordset($1::jsonb) as e (owner int, book int, enddate timestamp)", [JSON.stringify(list)]).then(function(r){
          r == null && (r = {});
          return res.send({});
        });
      });
      api.get('/read/:key', aux.validateKey, aux.signedin, function(req, res){
        return db.query("with merged as (\n  select r as read, b as book from read as r\n  left join book as b on b.key = r.book\n  where r.owner = $1\n)\nselect row_to_json(m.read) as read, row_to_json(m.book) as book from merged as m", [req.params.key]).then(function(r){
          r == null && (r = {});
          return res.send(r.rows || (r.rows = []));
        });
      });
      /* TODO finish the query for update
      api.put \/read/:key/, aux.validate-key, aux.signedin, (req, res) ->
        # TODO we should make it possible to update read records in other account if they agree.
        if req.user.key != req.params.key => return lderror.reject 403
        # TODO we may add book here too with fields such as req.body.books
        # this requires additional fields in req.body.list to recognize books to be added
        db.query """
        update read (book,date) values
        select * from jsonb_to_recordset($1::jsonb) as e (book int, date timestamp)
        """, [JSON.stringify list]
          .then (r={}) ->
            res.send!
      */
      api.put('/read/:key/delete', aux.validateKey, aux.signedin, function(req, res){
        var list;
        if (req.user.key !== req.params.key) {
          return lderror.reject(403);
        }
        list = (Array.isArray(req.body.list)
          ? req.body.list
          : [req.body.list]).filter(function(it){
          return it && it.key;
        });
        list = list.map(function(it){
          return it.key;
        });
        return db.query("delete from read where owner = $1 and key in ANY($2)", [req.user.key, list]).then(function(r){
          r == null && (r = {});
          return res.send(r.rows || (r.rows = []));
        });
      });
      api.get('/readlist/:owner?', aux.signedin, function(req, res){
        var owner;
        if (req.params.owner != null && req.params.owner !== req.user.key) {
          return lderror.reject(403);
        }
        owner = req.user.key;
        return db.query("select * from readlist where owner = $1", [owner]).then(function(r){
          r == null && (r = {});
          return res.send(r.rows || (r.rows = []));
        });
      });
      return api.post('/readlist/:owner?', aux.signedin, function(req, res){
        var owner;
        if (req.params.owner != null && req.params.owner !== req.user.key) {
          return lderror.reject(403);
        }
        if (!req.body.title) {
          return lderror.reject(400);
        }
        owner = req.user.key;
        return db.query("insert into readlist (title,owner) values ($1, $2) returning key", [req.body.title, owner]).then(function(r){
          r == null && (r = {});
          return res.send((r.rows || (r.rows = []))[0] || {});
        });
      });
    });
  });
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
}).call(this);
